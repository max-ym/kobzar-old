use arch;
use arch::xsave;
use super::process::{CsRegs, ProcessH};
use arch::regf;

/// Processor Data Table. Each entry corresponds to local APIC ID which
/// identifies processor ID. This is Kobzar arhitectural struct, not
/// related to Intel arch.
/// It supports currently up to 256 processors or cores.
///
/// Each entry is a pointer to process handle that is currently running on
/// the core.
///
/// This struct is used by assebly routine isr_sched_process_change.
/// When making changes don't forget to reflect them to FASM code.
#[repr(packed)]
pub struct Pdt {
    arr     : [*mut ProcessH; 256],
}

/// IsrStack that is generated by ISR isr_sched_process_change for Rust
/// part of ISR.
#[repr(packed)]
pub struct IsrStack {
    ss      : u64,
    rsp     : u64,
    rflags  : u64,
    cs      : u64,
    rip     : u64,

    regs    : regf::GeneralPurpose,
}

/// Rust part of IST that handles process change signal
/// from the scheduler. Assembler routine saves GP registers
/// (if corresponding flag is set) before calling
/// this function so that GP regisers
/// could be safely used here.
#[no_mangle]
pub extern "C" fn rust_isr_sched_process_change(
        stk: *mut IsrStack, ph: *mut ProcessH) {

    let ph  = unsafe { &mut *ph  };
    let stk = unsafe { &mut *stk };

    // Save general purpose regs if required.
    if ph.has_gp_regs() {
        let src = &stk.regs;
        let dst = unsafe { &mut *ph.gp_regs_mut() };

        dst.gp.rax = src.rax;
        dst.gp.rbx = src.rbx;
        dst.gp.rcx = src.rcx;
        dst.gp.rdx = src.rdx;
        dst.gp.rsi = src.rsi;
        dst.gp.rdi = src.rdi;
        dst.gp.rbp = src.rbp;
        dst.gp.r8  = src.r8 ;
        dst.gp.r9  = src.r9 ;
        dst.gp.r10 = src.r10;
        dst.gp.r11 = src.r11;
        dst.gp.r12 = src.r12;
        dst.gp.r13 = src.r13;
        dst.gp.r14 = src.r14;
        dst.gp.r15 = src.r15;

        dst.st.rsp = stk.rsp;
        dst.st.rip = stk.rip;
        dst.st.rflags = stk.rflags;
    }

    unimplemented!()
}
